
# drmaatcl test suit.
# based on DRMAA_TEST_SUITE_VERSION "1.7.2"

set JOB_CHUNK	2
set NTHREADS	3
set NBULKS	3

# TODO: should really come from command line
set sleeper_job	"/bin/sleep"
set exit_job	"/usr/local/bin/test_exit_helper"
set kill_job	"/usr/local/bin/test_kill_helper"

# DRMAA_TIMEOUT_WAIT_FOREVER is anyway useless in a test suite
# we assume some local setting, fast enough for the single job runs
set max_wait 3600

# shorter names to help the reader
set ANY_JOB	$drmaa::DRMAA_JOB_IDS_SESSION_ANY
set ALL_JOBS	$drmaa::DRMAA_JOB_IDS_SESSION_ALL

# Tcl does not have a common garden (POSIX) sleep command
proc sleep {seconds} {
	after [expr 1000*$seconds]
}

# error report for investigation by user
# args are as generated by catch
proc error_report {result options} {
	puts stderr "=== result ========"
	puts stderr $result
	puts stderr "=== Error Trace ==="
	puts stderr $options
	puts stderr "==================="
}

proc create_sleeper_job_template {seconds in_hold} {
	global sleeper_job
	# catch the errors, and pass them to the caller
	if [catch {	set jt [drmaa::drmaa_allocate_job_template]
			drmaa::drmaa_set_attribute $jt drmaa_wd $drmaa::DRMAA_PLACEHOLDER_HD
			drmaa::drmaa_set_attribute $jt drmaa_remote_command $sleeper_job
			drmaa::drmaa_set_vector_attribute $jt drmaa_v_argv $seconds
			if $in_hold {
				drmaa::drmaa_set_attribute $jt drmaa_js_state $drmaa::DRMAA_SUBMISSION_STATE_HOLD
			} } result options] {
		return -code error $options
	}
	return $jt
}

proc create_exit_job_template {} {
	global exit_job
	# catch the errors, and pass them to the caller
	if [catch {	set jt [drmaa::drmaa_allocate_job_template]
			drmaa::drmaa_set_attribute $jt drmaa_wd $drmaa::DRMAA_PLACEHOLDER_HD
			drmaa::drmaa_set_attribute $jt drmaa_remote_command $exit_job
			drmaa::drmaa_set_vector_attribute $jt drmaa_v_argv 0
			drmaa::drmaa_set_attribute $jt drmaa_output_path ":/dev/null"
			} result options] {
		return -code error $options
	}
	return $jt
}

# wait for all ST jobs
proc wait_all_st_jobs {njobs} {
	global ANY_JOB max_wait
	puts "\twaiting for $njobs jobs"
	while {$njobs>0} {
		if [catch {set wout [drmaa::drmaa_wait $ANY_JOB $max_wait]} result options] {
			if {[lindex $result 1] != "INVALID_JOB"} {
				return $options
			}
			break
		}
		set jobid [lindex $wout 0]
		puts "\twaited job >$jobid<"
		incr njobs -1
	}
	puts "\twaited for last job"
	return
}

# submit nbulks of jchunk jobs
proc submit_bulk_sleeper_jobs {seconds in_hold nbulk jchunk} {
	set all_jobids {}
	if [catch {	set jt [create_sleeper_job_template $seconds $in_hold]
			for {set i 0} {$i<$nbulk} {incr i} {
				set jobids [drmaa::drmaa_run_bulk_jobs $jt 1 $jchunk 1]
				set all_jobids [concat $all_jobids " " $jobids]
				puts "\tSubmitted $jchunk bulk jobs with job ids: $jobids"
			}
			drmaa::drmaa_delete_job_template $jt} result options] {
		return -code error $options
	}
	return $all_jobids
}

# submit individual sleeper job(s)
proc submit_sleeper_jobs {seconds in_hold njobs} {
	set all_jobids {}
	if [catch {	set jt [create_sleeper_job_template $seconds $in_hold]
			for {set i 0} {$i<$njobs} {incr i} {
				set jobid [drmaa::drmaa_run_job $jt]
				lappend all_jobids $jobid
				puts "\tsubmitted job >$jobid<"
			}
			drmaa::drmaa_delete_job_template $jt} result options] {
		return -code error $options
	}
	return $all_jobids
}

# wait for individual jobs
proc wait_individual_jobs {all_jobids} {
	global max_wait
	puts "\twaiting for $all_jobids"
	if [catch {	foreach jobid $all_jobids {
				while 1 {
					if [catch {set wout [drmaa::drmaa_wait $jobid $max_wait]} res opt] {
						set err [lindex $res 1]
						if {$err =="DRM_COMMUNICATIONS_FAILURE"} {
							sleep 1
							continue
						} elseif {$err != "INVALID_JOB"} {
							error_report $res $opt
							return -code error
						}
						break
					}
					set real_job_id [lindex $wout 0]
					puts "\twaited job >$real_job_id<"
					break
				}
			}} result options] {
		return -code error $options
	}
	puts "\twaited all jobs"
	return
}

proc check_term_details {stat exp_aborted exp_exited exp_signaled} {
	if [catch {	set aborted [drmaa::drmaa_wifaborted $stat]
			if {$exp_aborted && !$aborted} {
				return -code error -errorinfo "Expected wifaborted = $exp_aborted got $aborted"
			}
			set exited [drmaa::drmaa_wifexited $stat]
			if {$exp_exited && !$exited} {
				return -code error -errorinfo "Expected wifexited = $exp_exited, got $exited"
			}
			set signaled [drmaa::drmaa_wifsignaled $stat]
			if {$exp_signaled && !$signaled} {
				return -code error -errorinfo "Expected wifsignaled = $exp_signaled, got $signaled"
			} } result options] {
		return -code error $options
	}
	return
}

proc check_job_state {jobid exp_jobstate} {
	set retry_count 3
	set retry_sleep 5
	while {$retry_count > 0} {
		set job_state [drmaa::drmaa_job_ps $jobid]
		if {$job_state == $exp_jobstate} {
			puts "\tjob state is $exp_jobstate, as expected"
			return
		} else {
			puts "\tCurrent job state is $job_state, expected $exp_jobstate,"
			puts "\ttrying to get another answer ($retry_count attempts left)"
			incr retry_count -1
			sleep $retry_sleep
		}
	}
	return -code error -errorinfo "Too many drmaa_job_ps retries, while $exp_jobstate was expected."
}

proc wait_n_jobs {njobs} {
	global max_wait ANY_JOB
	for {set i 0} {$i<$njobs} {incr i} {
		while {1} {
			if [catch {set wout [drmaa::drmaa_wait $ANY_JOB $max_wait]} result options] {
				if {[lindex $result 1]=="TRY_LATER"} {
					puts "\tretry ..."
					continue
				}
				return -code error $options
			}
			set jobid [lindex $wout 0]
			break;
		}
	}
	puts "\twaiting for any job resulted in finished job $jobid"
	return
}

proc ST_MULT_INIT {} {
	# init - should succeed
	if [catch {drmaa::drmaa_init} result options] {
		error_report $result $options
		return -code error
	}
	# init again should fail
	if {[catch {drmaa::drmaa_init} result options]} {
		if {[lindex $result 1] != "ALREADY_ACTIVE_SESSION"} {
			error_report $result $options
			return -code error
		}
	} else {
		return -code error "second drmaa_init succeeded!"
	}
	# exit
	if [catch {drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_MULT_EXIT {} {
	# init + exit
	if [catch {drmaa::drmaa_init; drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	# exit again
	if {[catch {drmaa::drmaa_exit} result options] == 0} {
		return -code error "second drmaa_exit succeeded!"
	}
	if {[lindex $result 1] != "NO_ACTIVE_SESSION"} then {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_SUPPORTED_ATTR {} {
	if [catch {	drmaa::drmaa_init
			set attrlist [drmaa::drmaa_get_attribute_names]
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	foreach attr $attrlist { puts "\t$attr" }
	return
}

proc ST_SUPPORTED_VATTR {} {
	if [catch {	drmaa::drmaa_init
			set attrlist [drmaa::drmaa_get_vector_attribute_names]
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	foreach attr $attrlist { puts "\t$attr" }
	return
}

proc ST_VERSION {} {
	if [catch {set maj_min [drmaa::drmaa_version]} result options] {
		error_report $result $options
		return -code error
	}
	puts "\tversion [join $maj_min .]"
	return
}

proc ST_DRM_SYSTEM {} {
	if [catch {	set DRM_system [drmaa::drmaa_get_DRM_system]
			puts "\tdrmaa_get_DRM_system returned \"$DRM_system\" before init."
			drmaa::drmaa_init
			set DRM_system [drmaa::drmaa_get_DRM_system]
			puts "\tdrmaa_get_DRM_system returned \"$DRM_system\" after init."
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_DRMAA_IMPL {} {
	if [catch {	set DRMAA_impl [drmaa::drmaa_get_DRMAA_implementation]
			puts "\tdrmaa_get_DRMAA_implementation returned \"$DRMAA_impl\" before init."
			drmaa::drmaa_init
			set DRMAA_impl [drmaa::drmaa_get_DRMAA_implementation]
			puts "\tdrmaa_get_DRMAA_implementation returned \"$DRMAA_impl\" after init."
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_CONTACT {} {
	if [catch {	set contact [drmaa::drmaa_get_contact]
			puts "\tdrmaa_get_contact returned \"$contact\" before init."
			drmaa::drmaa_init
			set DRMAA_impl [drmaa::drmaa_get_DRMAA_implementation]
			puts "\tdrmaa_get_contact returned \"$contact\" after init."
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_EMPTY_SESSION_WAIT {} {
	global max_wait
	if [catch {drmaa::drmaa_init} result options] {
		error_report $result $options
		return -code error
	}
	if [catch {drmaa::drmaa_wait $drmaa::DRMAA_JOB_IDS_SESSION_ANY $max_wait
			} result options] {
		if {[lindex $result 1] != "INVALID_JOB"} {
			error_report $result $options
			return -code error
		}
	} else {
		return -code error "drmaa_wait returned success!"
	}
	if [catch {drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_EMPTY_SESSION_SYNCHRONIZE_DISPOSE {} {
	global max_wait
	if [catch {	drmaa::drmaa_init
			drmaa::drmaa_synchronize $max_wait 1 $drmaa::DRMAA_JOB_IDS_SESSION_ALL
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_EMPTY_SESSION_SYNCHRONIZE_NODISPOSE {} {
	global max_wait
	if [catch {	drmaa::drmaa_init
			drmaa::drmaa_synchronize $max_wait 0 $drmaa::DRMAA_JOB_IDS_SESSION_ALL
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_EMPTY_SESSION_CONTROL {action} {
	if [catch {	drmaa::drmaa_init
			drmaa::drmaa_control $drmaa::DRMAA_JOB_IDS_SESSION_ALL $action
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_SUBMIT_WAIT {} {
	global JOB_CHUNK
	if [catch {	drmaa::drmaa_init
			submit_sleeper_jobs 5 0 $JOB_CHUNK
			wait_all_st_jobs $JOB_CHUNK
			drmaa::drmaa_exit
			} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_BULK_SUBMIT_WAIT {} {
	global NBULKS JOB_CHUNK
	if [catch {	drmaa::drmaa_init
			submit_bulk_sleeper_jobs 5 0 $NBULKS $JOB_CHUNK
			wait_all_st_jobs [expr $NBULKS*$JOB_CHUNK]
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return
}

proc ST_BULK_SINGLESUBMIT_WAIT_INDIVIDUAL {} {
	global NBULKS JOB_CHUNK max_wait
	set all_jobids {}
	if [catch {	drmaa::drmaa_init
			set all_jobids [concat $all_jobids [submit_bulk_sleeper_jobs 5 0 $NBULKS $JOB_CHUNK]]
			set all_jobids [concat $all_jobids [submit_sleeper_jobs 5 0 $JOB_CHUNK]]
			wait_individual_jobs $all_jobids
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return

}

proc ST_SUBMITMIXTURE_SYNC_ALL_DISPOSE {} {
	global NBULKS JOB_CHUNK max_wait ALL_JOBS
	if [catch {	drmaa::drmaa_init
			submit_bulk_sleeper_jobs 5 0 $NBULKS $JOB_CHUNK
			submit_sleeper_jobs 5 0 $JOB_CHUNK
			puts "\tsynchronizing with all jobs."
			drmaa::drmaa_synchronize $max_wait 1 $ALL_JOBS
			puts "\tsynchronized with all jobs."
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return
}

proc ST_SUBMITMIXTURE_SYNC_ALL_NODISPOSE {} {
	global NBULKS JOB_CHUNK max_wait ALL_JOBS
	set all_jobids {}
	if [catch {	drmaa::drmaa_init
			set bjobs [submit_bulk_sleeper_jobs 5 0 $NBULKS $JOB_CHUNK]
			set ijobs [submit_sleeper_jobs 5 0 $JOB_CHUNK]
			set all_jobids [concat $bjobs " " $ijobs]
			puts "\tsynchronizing with all jobs."
			drmaa::drmaa_synchronize $max_wait 1 $ALL_JOBS
			puts "\tsynchronized with all jobs."
			wait_individual_jobs $all_jobids
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return
}

proc ST_SUBMITMIXTURE_SYNC_ALLIDS_DISPOSE {} {
	global NBULKS JOB_CHUNK max_wait ALL_JOBS
	set all_jobids {}
	if [catch {	drmaa::drmaa_init
			set bjobs [submit_bulk_sleeper_jobs 5 0 $NBULKS $JOB_CHUNK]
			set ijobs [submit_sleeper_jobs 5 0 $JOB_CHUNK]
			set all_jobids [concat $bjobs " " $ijobs]
			puts "\tsynchronizing: $all_jobids"
			drmaa::drmaa_synchronize $max_wait 1 {*}$all_jobids
			puts "\tsynchronized with all jobs."
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return

}

proc ST_SUBMITMIXTURE_SYNC_ALLIDS_NODISPOSE {} {
	global NBULKS JOB_CHUNK max_wait ALL_JOBS
	set all_jobids {}
	if [catch {	drmaa::drmaa_init
			set bjobs [submit_bulk_sleeper_jobs 5 0 $NBULKS $JOB_CHUNK]
			set ijobs [submit_sleeper_jobs 5 0 $JOB_CHUNK]
			set all_jobids [concat $bjobs " " $ijobs]
			puts "\tsynchronizing: $all_jobids"
			drmaa::drmaa_synchronize $max_wait 0 {*}$all_jobids
			puts "\tsynchronized with all jobs."
			wait_individual_jobs $all_jobids
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return


}

proc ST_EXIT_STATUS {} {
	global max_wait
	set alljobs {}
	if [catch {	drmaa::drmaa_init
			set jt [create_exit_job_template]
			for {set i 0} {$i<126} {incr i} {
				drmaa::drmaa_set_vector_attribute $jt drmaa_v_argv $i
				set jobid [drmaa::drmaa_run_job $jt]
				lappend alljobs $jobid
				puts "\t$i\t$jobid"
			}
			drmaa::drmaa_delete_job_template $jt
			for {set i 0} {$i<126} {incr i} {
				set jobid [lindex $alljobs $i]
				while 1 {
					if [catch {set wout [drmaa::drmaa_wait $jobid $max_wait]} res opts] {
						if {[lindex $res 1] == "DRM_COMMUNICATIONS_FAILURE"} {
							sleep(1)
						}
						error_report $result $options
						return -code error $options
					}
					puts "job $i with job id $jobid finished"
					break
				}
				set jobstat [lindex $wout 1]
				if {! [drmaa::drmaa_wifexited $jobstat]} {
					return -code error "Job $jobid did not exit cleanly"
				}
				set exit_status [drmaa::drmaa_wexitstatus $jobstat]
				if {$exit_status != $i} {
					return -code error "Job $jobid returned $exit_status instead of $i!"
				}
			}
			puts "\twaited all jobs"
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return
}

proc ST_SUBMIT_KILL_SIG {} {
	global kill_job max_wait
	array set sigList {
		 1	SIGHUP
		 3	SIGQUIT
		 4	SIGILL
		 6	SIGABRT
		 8	SIGFPE
		 9	SIGKILL
		10	SIGUSR1
		11	SIGSEGV
		12	SIGUSR2
		14	SIGALRM
		15	SIGTERM
	}
	if [catch {	drmaa::drmaa_init
			set jt [drmaa::drmaa_allocate_job_template]
			drmaa::drmaa_set_attribute $jt drmaa_wd $drmaa::DRMAA_PLACEHOLDER_HD
			drmaa::drmaa_set_attribute $jt drmaa_remote_command $kill_job
			drmaa::drmaa_set_attribute $jt drmaa_output_path ":/dev/null"
			foreach {sig exp_sigName} [array get sigList] {
				puts "\tTesting with $exp_sigName ($sig)"
				drmaa::drmaa_set_vector_attribute $jt drmaa_v_argv $sig
				set jobid [drmaa::drmaa_run_job $jt]
				puts "\tsubmitted job $jobid"
				set wout [drmaa::drmaa_wait $jobid $max_wait]
				set jobstat [lindex $wout 1]
				check_term_details $jobstat 0 0 1
				set sigName [drmaa::drmaa_wtermsig $jobstat]
				if {$sigName == $exp_sigName} {
					puts -nonewline "\tjob $jobid was killed with $sigName, as expected"
					set was_dumped [drmaa::drmaa_wcoredump $jobstat]
					if $was_dumped {
						puts " (with core dump file)"
					} else {
						puts " (without core dump file)"
					}
				} else {
					return -code error -errorinfo "Reported signal is $sigName, expected $exp_sigName."
				}
			}
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return
}

proc ST_INPUT_FILE_FAILURE {} {
	global sleeper_job max_wait ALL_JOBS
	if [catch {	drmaa::drmaa_init
			set jt [create_sleeper_job_template 5 0]
			drmaa::drmaa_set_attribute $jt drmaa_input_path ":nonexistent_file"
			set jobid [drmaa::drmaa_run_job $jt]
			puts "\tsubmitted job $jobid"
			drmaa::drmaa_delete_job_template $jt
			puts "\tsynchronizing: $ALL_JOBS"
			drmaa::drmaa_synchronize $max_wait 0 $ALL_JOBS
			puts "\tsynchronized with job finish"
			check_job_state $jobid FAILED
			drmaa::drmaa_wait $jobid $drmaa::DRMAA_TIMEOUT_NO_WAIT
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return
}

proc ST_OUTPUT_FILE_FAILURE {} {
	global sleeper_job max_wait ALL_JOBS
	if [catch {	drmaa::drmaa_init
			set jt [create_sleeper_job_template 5 0]
			drmaa::drmaa_set_attribute $jt drmaa_join_files "y"
			drmaa::drmaa_set_attribute $jt drmaa_output_path ":nonwritable_file"
			set jobid [drmaa::drmaa_run_job $jt]
			puts "\tsubmitted job $jobid"
			drmaa::drmaa_delete_job_template $jt
			puts "\tsynchronizing: $ALL_JOBS"
			drmaa::drmaa_synchronize $max_wait 0 $ALL_JOBS
			puts "\tsynchronized with job finish"
			check_job_state $jobid FAILED
			drmaa::drmaa_wait $jobid $drmaa::DRMAA_TIMEOUT_NO_WAIT
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return
}

proc ST_ERROR_FILE_FAILURE {} {
	global sleeper_job max_wait ALL_JOBS
	if [catch {	drmaa::drmaa_init
			set jt [create_sleeper_job_template 5 0]
			drmaa::drmaa_set_attribute $jt drmaa_join_files "n"
			drmaa::drmaa_set_attribute $jt drmaa_error_path ":nonwritable_file"
			set jobid [drmaa::drmaa_run_job $jt]
			puts "\tsubmitted job $jobid"
			drmaa::drmaa_delete_job_template $jt
			puts "\tsynchronizing: $ALL_JOBS"
			drmaa::drmaa_synchronize $max_wait 0 $ALL_JOBS
			puts "\tsynchronized with job finish"
			check_job_state $jobid FAILED
			drmaa::drmaa_wait $jobid $drmaa::DRMAA_TIMEOUT_NO_WAIT
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return
}

proc ST_SUBMIT_IN_HOLD_RELEASE {} {
	global max_wait ALL_JOBS
	if [catch {	drmaa::drmaa_init
			set jt [create_sleeper_job_template 5 1]
			set job_id [drmaa::drmaa_run_job $jt]
			drmaa::drmaa_delete_job_template $jt
			puts "\tsubmitted job in hold state $job_id"
			check_job_state $job_id USER_ON_HOLD
			puts "\tverified user hold state for job $job_id"
			drmaa::drmaa_control $job_id RELEASE
			puts "\treleased user hold state for job $job_id"
			drmaa::drmaa_synchronize $max_wait 0 $ALL_JOBS
			puts "\tsynchronized with job finish"
			check_job_state $job_id DONE
			wait_n_jobs 1
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_SUBMIT_IN_HOLD_DELETE {x} {}

proc ST_BULK_SUBMIT_IN_HOLD_SESSION_RELEASE {x} {}

proc ST_BULK_SUBMIT_IN_HOLD_SINGLE_RELEASE {x} {}

proc ST_BULK_SUBMIT_IN_HOLD_SESSION_DELETE {x} {}

proc ST_BULK_SUBMIT_IN_HOLD_SINGLE_DELETE {x} {}

proc ST_SUBMIT_POLLING_WAIT_TIMEOUT {x} {}

proc ST_SUBMIT_POLLING_WAIT_ZEROTIMEOUT {x} {}

proc ST_SUBMIT_POLLING_SYNCHRONIZE_TIMEOUT {x} {}

proc ST_SUBMIT_POLLING_SYNCHRONIZE_ZEROTIMEOUT {x} {}

proc ST_ATTRIBUTE_CHANGE {} {}

proc ST_SUBMIT_SUSPEND_RESUME_WAIT {x} {}

proc ST_USAGE_CHECK {x} {}

proc ST_UNSUPPORTED_ATTR {} {}

proc ST_UNSUPPORTED_VATTR {} {}

proc MT_SUBMIT_WAIT {x} {}

proc MT_SUBMIT_BEFORE_INIT_WAIT {x} {}

proc MT_EXIT_DURING_SUBMIT {x} {}

proc MT_SUBMIT_MT_WAIT {x} {}

proc MT_EXIT_DURING_SUBMIT_OR_WAIT {x} {}

proc ST_GET_NUM_JOBIDS {x} {}

proc ST_BULK_SUBMIT_INCRPH {x} {}

