
# drmaatcl test suit.
# based on DRMAA_TEST_SUITE_VERSION "1.7.2"

set JOB_CHUNK	2
set NTHREADS	3
set NBULKS	3

set sleeper_job "/bin/sleep"	;# should really come from command line

# DRMAA_TIMEOUT_WAIT_FOREVER is anyway useless in a test suite
# we assume some local setting, fast enough for the single job runs
set max_wait 3600

# shorter names to help the reader
set ANY_JOB	$drmaa::DRMAA_JOB_IDS_SESSION_ANY 
set ALL_JOBS	$drmaa::DRMAA_JOB_IDS_SESSION_ALL

# Tcl does not have a common garden (POSIX) sleep command
proc sleep {seconds} {
	after [expr 1000*seconds]
}

# error report for investigation by user
# args are as generated by catch
proc error_report {result options} {
	puts stderr "=== result ========"
	puts stderr $result
	puts stderr "=== Error Trace ==="
	puts stderr $options
	puts stderr "==================="
}

proc create_sleeper_job_template {seconds in_hold} {
	global sleeper_job
	# catch the errors, and pass them to the caller
	if [catch {	set jt [drmaa::drmaa_allocate_job_template]
			drmaa::drmaa_set_attribute $jt drmaa_wd $drmaa::DRMAA_PLACEHOLDER_HD
			drmaa::drmaa_set_attribute $jt drmaa_remote_command $sleeper_job
			drmaa::drmaa_set_vector_attribute $jt drmaa_v_argv $seconds
			if $in_hold {
				drmaa::drmaa_set_attribute $jt drmaa_js_state $drmaa::DRMAA_SUBMISSION_STATE_HOLD
			} } result options] {
		return $options
	}
	return $jt
}

# wait for all ST jobs
proc wait_all_st_jobs {njobs} {
	global ANY_JOB max_wait
	puts "\twaiting for $njobs jobs"
	while {$njobs>0} {
		if [catch {set wout [drmaa::drmaa_wait $ANY_JOB $max_wait]} result options] {
			if {[lindex $result 1] != "INVALID_JOB"} {
				return $options
			}
			break
		}
		set jobid [lindex $wout 0]
		puts "\twaited job >$jobid<"
		incr njobs -1
	}
	puts "\twaited for last job"
	return
}

# submit nbulks of jchunk jobs
proc submit_bulk_sleeper_jobs {seconds in_hold nbulk jchunk} {
	set all_jobids {}
	if [catch {	set jt [create_sleeper_job_template $seconds $in_hold]
			for {set i 0} {$i<$nbulk} {incr i} {
				set jobids [drmaa::drmaa_run_bulk_jobs $jt 1 $jchunk 1]
				set all_jobids [concat $all_jobids " " $jobids]
				puts "\tSubmitted $jchunk bulk jobs with job ids: $jobids"
			}
			drmaa::drmaa_delete_job_template $jt} result options] {
		return -code error $options
	}
	return $all_jobids
}

# submit individual sleeper job(s)
proc submit_sleeper_jobs {seconds in_hold njobs} {
	set all_jobids {}
	if [catch {	set jt [create_sleeper_job_template $seconds $in_hold]
			for {set i 0} {$i<$njobs} {incr i} {
				set jobid [drmaa::drmaa_run_job $jt]
				lappend all_jobids $jobid
				puts "\tsubmitted job >$jobid<"
			}
			drmaa::drmaa_delete_job_template $jt} result options] {
		return -code error $options
	}
	return $all_jobids
}

# wait for individual jobs
proc wait_individual_jobs {all_jobids} {
	global max_wait
	puts "\twaiting for $all_jobids"
	if [catch {	foreach jobid $all_jobids {
				while 1 {
					if [catch {set wout [drmaa::drmaa_wait $jobid $max_wait]} res opt] {
						set err [lindex $res 1]
						if {$err =="DRM_COMMUNICATIONS_FAILURE"} {
							sleep 1
							continue
						} elseif {$err != "INVALID_JOB"} {
							error_report $res $opt
							return -code error
						}
						break
					}
					set real_job_id [lindex $wout 0]
					puts "\twaited job >$real_job_id<"
					break
				}
			}} result options] {
		return -code error $options
	}
	puts "\twaited all jobs"
	return
}

proc ST_MULT_INIT {} {
##	ST_MULT_INIT,
##	- drmaa_init() is called multiple times
##	- first time it must succeed - second time it must fail
##	- then drmaa_exit() is called
	# init - should succeed
	if [catch {drmaa::drmaa_init} result options] {
		error_report $result $options
		return -code error
	}
	# init again should fail
	if {[catch {drmaa::drmaa_init} result options]} {
		if {[lindex $result 1] != "ALREADY_ACTIVE_SESSION"} {
			error_report $result $options
			return -code error
		}
	} else {
		return -code error "second drmaa_init succeeded!"
	}
	# exit
	if [catch {drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_MULT_EXIT {} {
##	ST_MULT_EXIT,
##	- drmaa_init() is called
##	- then drmaa_exit() is called multiple times
##	- first time it must succeed - second time it must fail
	# init + exit
	if [catch {drmaa::drmaa_init; drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	# exit again
	if {[catch {drmaa::drmaa_exit} result options] == 0} {
		return -code error "second drmaa_exit succeeded!"
	}
	if {[lindex $result 1] != "NO_ACTIVE_SESSION"} then {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_SUPPORTED_ATTR {} {
##	ST_SUPPORTED_ATTR,
##	- drmaa_init() is called
##	- drmaa_get_attribute_names() is called
##	- the names of all supported non vector attributes are printed
##	- then drmaa_exit() is called
	if [catch {	drmaa::drmaa_init
			set attrlist [drmaa::drmaa_get_attribute_names]
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	foreach attr $attrlist { puts "\t$attr" }
	return
}

proc ST_SUPPORTED_VATTR {} {
##	ST_SUPPORTED_VATTR,
##	- drmaa_init() is called
##	- drmaa_get_vector_attribute_names() is called
##	- the names of all supported vector attributes are printed
##	- then drmaa_exit() is called
	if [catch {	drmaa::drmaa_init
			set attrlist [drmaa::drmaa_get_vector_attribute_names]
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	foreach attr $attrlist { puts "\t$attr" }
	return
}

proc ST_VERSION {} {
##	ST_VERSION,
##	- drmaa_version() is called
##	- version information is printed
	if [catch {set maj_min [drmaa::drmaa_version]} result options] {
		error_report $result $options
		return -code error
	}
	puts "\tversion [join $maj_min .]"
	return
}

proc ST_DRM_SYSTEM {} {
##	ST_DRM_SYSTEM,
##	- drmaa_get_DRM_system() is called
##	- the contact string is printed
##	- drmaa_init() is called
##	- drmaa_get_DRM_system() is called
##	- the DRM system name is printed
##	- then drmaa_exit() is called
	if [catch {	set DRM_system [drmaa::drmaa_get_DRM_system]
			puts "\tdrmaa_get_DRM_system returned \"$DRM_system\" before init."
			drmaa::drmaa_init
			set DRM_system [drmaa::drmaa_get_DRM_system]
			puts "\tdrmaa_get_DRM_system returned \"$DRM_system\" after init."
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_DRMAA_IMPL {} {
##	ST_DRMAA_IMPL,
##	- drmaa_get_DRM_system() is called
##	- the contact string is printed
##	- drmaa_init() is called
##	- drmaa_get_DRMAA_implementation() is called
##	- the DRMAA implemention name is printed
##	- then drmaa_exit() is called
	if [catch {	set DRMAA_impl [drmaa::drmaa_get_DRMAA_implementation]
			puts "\tdrmaa_get_DRMAA_implementation returned \"$DRMAA_impl\" before init."
			drmaa::drmaa_init
			set DRMAA_impl [drmaa::drmaa_get_DRMAA_implementation]
			puts "\tdrmaa_get_DRMAA_implementation returned \"$DRMAA_impl\" after init."
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_CONTACT {} {
##	ST_CONTACT,
##	- drmaa_get_contact() is called
##	- the contact string is printed
##	- drmaa_init() is called
##	- drmaa_get_contact() is called
##	- the contact string is printed
##	- then drmaa_exit() is called
	if [catch {	set contact [drmaa::drmaa_get_contact]
			puts "\tdrmaa_get_contact returned \"$contact\" before init."
			drmaa::drmaa_init
			set DRMAA_impl [drmaa::drmaa_get_DRMAA_implementation]
			puts "\tdrmaa_get_contact returned \"$contact\" after init."
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_EMPTY_SESSION_WAIT {} {
##	ST_EMPTY_SESSION_WAIT,
##	- drmaa_init() is called
##	- drmaa_wait() must return DRMAA_ERRNO_INVALID_JOB
##	- then drmaa_exit() is called
	global max_wait
	if [catch {drmaa::drmaa_init} result options] {
		error_report $result $options
		return -code error
	}
	if [catch {drmaa::drmaa_wait $drmaa::DRMAA_JOB_IDS_SESSION_ANY $max_wait
			} result options] {
		if {[lindex $result 1] != "INVALID_JOB"} {
			error_report $result $options
			return -code error
		}
	} else {
		return -code error "drmaa_wait returned success!"
	}
	if [catch {drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_EMPTY_SESSION_SYNCHRONIZE_DISPOSE {} {
##	ST_EMPTY_SESSION_SYNCHRONIZE_DISPOSE,
##	- drmaa_init() is called
##	- drmaa_synchronize(DRMAA_JOB_IDS_SESSION_ALL, dispose=true) must return DRMAA_ERRNO_SUCCESS
##	- then drmaa_exit() is called
	global max_wait
	if [catch {	drmaa::drmaa_init
			drmaa::drmaa_synchronize $max_wait 1 $drmaa::DRMAA_JOB_IDS_SESSION_ALL
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_EMPTY_SESSION_SYNCHRONIZE_NODISPOSE {} {
##	ST_EMPTY_SESSION_SYNCHRONIZE_NODISPOSE,
##	- drmaa_init() is called
##	- drmaa_synchronize(DRMAA_JOB_IDS_SESSION_ALL, dispose=false) must return DRMAA_ERRNO_SUCCESS
##	- then drmaa_exit() is called
	global max_wait
	if [catch {	drmaa::drmaa_init
			drmaa::drmaa_synchronize $max_wait 0 $drmaa::DRMAA_JOB_IDS_SESSION_ALL
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_EMPTY_SESSION_CONTROL {action} {
##	ST_EMPTY_SESSION_CONTROL,
##	- drmaa_init() is called
##	- drmaa_control(DRMAA_JOB_IDS_SESSION_ALL, <passed control operation>) must return DRMAA_ERRNO_SUCCESS
##	- then drmaa_exit() is called
	if [catch {	drmaa::drmaa_init
			drmaa::drmaa_control $drmaa::DRMAA_JOB_IDS_SESSION_ALL $action
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_SUBMIT_WAIT {} {
##	ST_SUBMIT_WAIT,
##	- one thread
##	- submit jobs
##	- wait for jobend
	global JOB_CHUNK
	if [catch {	drmaa::drmaa_init
			submit_sleeper_jobs 5 0 $JOB_CHUNK
			wait_all_st_jobs $JOB_CHUNK
			drmaa::drmaa_exit
			} result options] {
		error_report $result $options
		return -code error
	}
	return
}

proc ST_BULK_SUBMIT_WAIT {} {
##	ST_BULK_SUBMIT_WAIT,
##	- drmaa_init() is called
##	- a bulk job is submitted and waited
##	- then drmaa_exit() is called
	global NBULKS JOB_CHUNK
	if [catch {	drmaa::drmaa_init
			submit_bulk_sleeper_jobs 5 0 $NBULKS $JOB_CHUNK
			wait_all_st_jobs [expr $NBULKS*$JOB_CHUNK]
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return
}

proc ST_BULK_SINGLESUBMIT_WAIT_INDIVIDUAL {} {
##	ST_BULK_SINGLESUBMIT_WAIT_INDIVIDUAL,
##	- drmaa_init() is called
##	- bulk and sequential jobs are submitted
##	- all jobs are waited individually
##	- then drmaa_exit() is called
	global NBULKS JOB_CHUNK max_wait
	set all_jobids {}
	if [catch {	drmaa::drmaa_init
			set all_jobids [concat $all_jobids [submit_bulk_sleeper_jobs 5 0 $NBULKS $JOB_CHUNK]]
			set all_jobids [concat $all_jobids [submit_sleeper_jobs 5 0 $JOB_CHUNK]]
			wait_individual_jobs $all_jobids
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error
	}
	return

}

proc ST_SUBMITMIXTURE_SYNC_ALL_DISPOSE {} {
##	ST_SUBMITMIXTURE_SYNC_ALL_DISPOSE,
##	- drmaa_init() is called
##	- submit a mixture of single and bulk jobs
##	- do drmaa_synchronize(DRMAA_JOB_IDS_SESSION_ALL, dispose)
##	to wait for all jobs to finish
##	- then drmaa_exit() is called
	global NBULKS JOB_CHUNK max_wait ALL_JOBS
	if [catch {	drmaa::drmaa_init
			submit_bulk_sleeper_jobs 5 0 $NBULKS $JOB_CHUNK
			submit_sleeper_jobs 5 0 $JOB_CHUNK
			puts "\tsynchronizing with all jobs."
			drmaa::drmaa_synchronize $max_wait 1 $ALL_JOBS
			puts "\tsynchronized with all jobs."
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return
}

proc ST_SUBMITMIXTURE_SYNC_ALL_NODISPOSE {} {
##	ST_SUBMITMIXTURE_SYNC_ALL_NODISPOSE,
##	- drmaa_init() is called
##	- submit a mixture of single and bulk jobs
##	- do drmaa_synchronize(DRMAA_JOB_IDS_SESSION_ALL, no-dispose)
##	to wait for all jobs to finish
##	- do drmaa_wait(DRMAA_JOB_IDS_SESSION_ANY) until
##	DRMAA_ERRNO_INVALID_JOB to reap all jobs
##	- then drmaa_exit() is called
	global NBULKS JOB_CHUNK max_wait ALL_JOBS
	set all_jobids {}
	if [catch {	drmaa::drmaa_init
			set bjobs [submit_bulk_sleeper_jobs 5 0 $NBULKS $JOB_CHUNK]
			set ijobs [submit_sleeper_jobs 5 0 $JOB_CHUNK]
			set all_jobids [concat $bjobs " " $ijobs]
			puts "\tsynchronizing with all jobs."
			drmaa::drmaa_synchronize $max_wait 1 $ALL_JOBS
			puts "\tsynchronized with all jobs."
			wait_individual_jobs $all_jobids
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return
}

proc ST_SUBMITMIXTURE_SYNC_ALLIDS_DISPOSE {} {
##	ST_SUBMITMIXTURE_SYNC_ALLIDS_DISPOSE,
##	- drmaa_init() is called
##	- submit a mixture of single and bulk jobs
##	- do drmaa_synchronize(all_jobids, dispose)
##	to wait for all jobs to finish
##	- then drmaa_exit() is called
	global NBULKS JOB_CHUNK max_wait ALL_JOBS
	set all_jobids {}
	if [catch {	drmaa::drmaa_init
			set bjobs [submit_bulk_sleeper_jobs 5 0 $NBULKS $JOB_CHUNK]
			set ijobs [submit_sleeper_jobs 5 0 $JOB_CHUNK]
			set all_jobids [concat $bjobs " " $ijobs]
			puts "\tsynchronizing: $all_jobids"
			drmaa::drmaa_synchronize $max_wait 1 {*}$all_jobids
			puts "\tsynchronized with all jobs."
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return

}

proc ST_SUBMITMIXTURE_SYNC_ALLIDS_NODISPOSE {} {
##	ST_SUBMITMIXTURE_SYNC_ALLIDS_NODISPOSE,
##	- drmaa_init() is called
##	- submit a mixture of single and bulk jobs
##	- do drmaa_synchronize(all_jobids, no-dispose)
##	to wait for all jobs to finish
##	- do drmaa_wait(DRMAA_JOB_IDS_SESSION_ANY) until
##	DRMAA_ERRNO_INVALID_JOB to reap all jobs
##	- then drmaa_exit() is called
	global NBULKS JOB_CHUNK max_wait ALL_JOBS
	set all_jobids {}
	if [catch {	drmaa::drmaa_init
			set bjobs [submit_bulk_sleeper_jobs 5 0 $NBULKS $JOB_CHUNK]
			set ijobs [submit_sleeper_jobs 5 0 $JOB_CHUNK]
			set all_jobids [concat $bjobs " " $ijobs]
			puts "\tsynchronizing: $all_jobids"
			drmaa::drmaa_synchronize $max_wait 0 {*}$all_jobids
			puts "\tsynchronized with all jobs."
			wait_individual_jobs $all_jobids
			drmaa::drmaa_exit} result options] {
		error_report $result $options
		return -code error $options
	}
	return


}

proc ST_EXIT_STATUS {x} {}
##	ST_EXIT_STATUS,
##	- drmaa_init() is called
##	- 255 job are submitted
##	- job i returns i as exit status (8 bit)
##	- drmaa_wait() verifies each job returned the
##	correct exit status
##	- then drmaa_exit() is called

proc ST_SUBMIT_KILL_SIG {x} {}
##	ST_SUBMIT_KILL_SIG,
##	- drmaa_init() is called
##	- one job is submitted
##	- job is killed via SIGKILL and SIGINT
##	- drmaa_wtermsig() is used to validate if the correct termination signals where reported
##	- drmaa_exit_is_called

proc ST_INPUT_FILE_FAILURE {x} {}
##	ST_INPUT_FILE_FAILURE,
##	- drmaa_init() is called
##	- a job is submitted with input/output/error path specification
##	that must cause the job to fail
##	- use drmaa_synchronize() to ensure job was started
##	- drmaa_job_ps() must return DRMAA_PS_FAILED
##	- drmaa_wait() must report drmaa_wifaborted() -> true
##	- then drmaa_exit() is called

proc ST_OUTPUT_FILE_FAILURE {x} {}
##	ST_OUTPUT_FILE_FAILURE,
##	- drmaa_init() is called
##	- a job is submitted with input/output/error path specification
##	that must cause the job to fail
##	- use drmaa_synchronize() to ensure job was started
##	- drmaa_job_ps() must return DRMAA_PS_FAILED
##	- drmaa_wait() must report drmaa_wifaborted() -> true
##	- then drmaa_exit() is called

proc ST_ERROR_FILE_FAILURE {x} {}
##	ST_ERROR_FILE_FAILURE,
##	- drmaa_init() is called
##	- a job is submitted with input/output/error path specification
##	that must cause the job to fail
##	- use drmaa_synchronize() to ensure job was started
##	- drmaa_job_ps() must return DRMAA_PS_FAILED
##	- drmaa_wait() must report drmaa_wifaborted() -> true
##	- then drmaa_exit() is called

proc ST_SUBMIT_IN_HOLD_RELEASE {x} {}
##	ST_SUBMIT_IN_HOLD_RELEASE,
##	- drmaa_init() is called
##	- a job is submitted with a user hold
##	- use drmaa_job_ps() to verify user hold state
##	- hold state is released using drmaa_control()
##	- the job is waited
##	- then drmaa_exit() is called
##	(still requires manual testing)
##

proc ST_SUBMIT_IN_HOLD_DELETE {x} {}
##	ST_SUBMIT_IN_HOLD_DELETE,
##	- drmaa_init() is called
##	- a job is submitted with a user hold
##	- use drmaa_job_ps() to verify user hold state
##	- job is terminated using drmaa_control()
##	- the job is waited and it is checked if wifaborted is true
##	- then drmaa_exit() is called
##	(still requires manual testing)
##

proc ST_BULK_SUBMIT_IN_HOLD_SESSION_RELEASE {x} {}
##	ST_BULK_SUBMIT_IN_HOLD_SESSION_RELEASE,
##	- drmaa_init() is called
##	- a bulk job is submitted with a user hold
##	- hold state is released for the session using drmaa_control()
##	- the job ids are waited
##	- then drmaa_exit() is called
##	(still requires manual testing)
##

proc ST_BULK_SUBMIT_IN_HOLD_SINGLE_RELEASE {x} {}
##	ST_BULK_SUBMIT_IN_HOLD_SINGLE_RELEASE,
##	- drmaa_init() is called
##	- a bulk job is submitted with a user hold
##	- hold state is released separately for each task using drmaa_control()
##	- the job ids are waited
##	- then drmaa_exit() is called
##	(still requires manual testing)
##

proc ST_BULK_SUBMIT_IN_HOLD_SESSION_DELETE {x} {}
##	ST_BULK_SUBMIT_IN_HOLD_SESSION_DELETE,
##	- drmaa_init() is called
##	- a bulk job is submitted with a user hold
##	- use drmaa_job_ps() to verify user hold state
##	- all session jobs are terminated using drmaa_control()
##	- the job ids are waited
##	- then drmaa_exit() is called
##	(still requires manual testing)
##

proc ST_BULK_SUBMIT_IN_HOLD_SINGLE_DELETE {x} {}
##	ST_BULK_SUBMIT_IN_HOLD_SINGLE_DELETE,
##	- drmaa_init() is called
##	- a bulk job is submitted with a user hold
##	- use drmaa_job_ps() to verify user hold state
##	- all session jobs are terminated using drmaa_control()
##	- the job ids are waited
##	- then drmaa_exit() is called
##	(still requires manual testing)
##

proc ST_SUBMIT_POLLING_WAIT_TIMEOUT {x} {}
##	ST_SUBMIT_POLLING_WAIT_TIMEOUT,
##	- drmaa_init() is called
##	- a single job is submitted
##	- repeatedly drmaa_wait() with a timeout is used until job is finished
##	- then drmaa_exit() is called

proc ST_SUBMIT_POLLING_WAIT_ZEROTIMEOUT {x} {}
##	ST_SUBMIT_POLLING_WAIT_ZEROTIMEOUT,
##	- drmaa_init() is called
##	- a single job is submitted
##	- repeatedly do drmaa_wait(DRMAA_TIMEOUT_NO_WAIT) + sleep() until job is finished
##	- then drmaa_exit() is called

proc ST_SUBMIT_POLLING_SYNCHRONIZE_TIMEOUT {x} {}
##	ST_SUBMIT_POLLING_SYNCHRONIZE_TIMEOUT,
##	- drmaa_init() is called
##	- a single job is submitted
##	- repeatedly drmaa_synchronize() with a timeout is used until job is finished
##	- then drmaa_exit() is called

proc ST_SUBMIT_POLLING_SYNCHRONIZE_ZEROTIMEOUT {x} {}
##	ST_SUBMIT_POLLING_SYNCHRONIZE_ZEROTIMEOUT,
##	- drmaa_init() is called
##	- a single job is submitted
##	- repeatedly do drmaa_synchronize(DRMAA_TIMEOUT_NO_WAIT) + sleep() until job is finished
##	- then drmaa_exit() is called

proc ST_ATTRIBUTE_CHANGE {} {}
##	ST_ATTRIBUTE_CHANGE,
##	- all attributes a written with different values for two times
##	- check if the JT is correct afterwards

proc ST_SUBMIT_SUSPEND_RESUME_WAIT {x} {}
##	ST_SUBMIT_SUSPEND_RESUME_WAIT,
##	- drmaa_init() is called
##	- a single job is submitted
##	- drmaa_job_ps() is used to actively wait until job is running
##	- drmaa_control() is used to suspend the job
##	- drmaa_job_ps() is used to verify job was suspended
##	- drmaa_control() is used to resume the job
##	- drmaa_job_ps() is used to verify job was resumed
##	- drmaa_wait() is used to wait for the jobs regular end
##	- then drmaa_exit() is called

proc ST_USAGE_CHECK {x} {}
##	ST_USAGE_CHECK,
##	- one thread
##	- submit jobs
##	- wait for jobend
##	- print job usage

proc ST_UNSUPPORTED_ATTR {} {}
##	// ST_UNSUPPORTED_ATTR,
##	- drmaa_init() is called
##	- drmaa_set_attribute() is called for an invalid attribute
##	- then drmaa_exit() is called

proc ST_UNSUPPORTED_VATTR {} {}
##	// ST_UNSUPPORTED_VATTR,
##	- drmaa_init() is called
##	- drmaa_set_vector_attribute() is called for an invalid attribute
##	- then drmaa_exit() is called

proc MT_SUBMIT_WAIT {x} {}
##	MT_SUBMIT_WAIT,
##	- multiple submission threads
##	- wait is done by main thread

proc MT_SUBMIT_BEFORE_INIT_WAIT {x} {}
##	MT_SUBMIT_BEFORE_INIT_WAIT,
##	- no drmaa_init() was called
##	- multiple threads try to submit but fail
##	- when drmaa_init() is called by main thread
##	submission proceed
##	- wait is done by main thread

proc MT_EXIT_DURING_SUBMIT {x} {}
##	MT_EXIT_DURING_SUBMIT,
##	- drmaa_init() is called
##	- multiple submission threads submitting (delayed) a series
##	of jobs
##	- during submission main thread does drmaa_exit()

proc MT_SUBMIT_MT_WAIT {x} {}
##	MT_SUBMIT_MT_WAIT,
##	- drmaa_init() is called
##	- multiple submission threads submit jobs and wait these jobs
##	- when all threads are finished main thread calls drmaa_exit()

proc MT_EXIT_DURING_SUBMIT_OR_WAIT {x} {}
##	MT_EXIT_DURING_SUBMIT_OR_WAIT,
##	- drmaa_init() is called
##	- multiple submission threads submit jobs and wait these jobs
##	- while submission threads are waiting their jobs the main
##	thread calls drmaa_exit()

proc ST_GET_NUM_JOBIDS {x} {}
##	ST_GET_NUM_JOBIDS,
##	- drmaa_init() ist called
##	- bulk job is submitted
##	- functionality of drmaa_get_num_jobids is tested
##	- drmaa_exit is called

proc ST_BULK_SUBMIT_INCRPH {x} {}
##	ST_BULK_SUBMIT_INCRPH
##	- drmaa_init() ist called
##	- bulk job is submitted
##	- drmaa_wd_ph and drmaa_incr_ph placeholders are used in output file name
##	- existence of files is checked
##	- drmaa_exit is called

